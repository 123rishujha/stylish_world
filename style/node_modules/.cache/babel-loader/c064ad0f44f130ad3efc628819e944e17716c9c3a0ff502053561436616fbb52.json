{"ast":null,"code":"import { useRef } from 'react';\nimport { isNodeOrChild } from './utils/is-node-or-child.mjs';\nimport { usePointerEvent, addPointerEvent } from '../events/use-pointer-event.mjs';\nimport { useUnmountEffect } from '../utils/use-unmount-effect.mjs';\nimport { pipe } from 'popmotion';\nimport { AnimationType } from '../render/utils/types.mjs';\nimport { isDragActive } from './drag/utils/lock.mjs';\n\n/**\r\n * @param handlers -\r\n * @internal\r\n */\nfunction useTapGesture(_ref) {\n  let {\n    onTap,\n    onTapStart,\n    onTapCancel,\n    whileTap,\n    visualElement\n  } = _ref;\n  const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n  const isPressing = useRef(false);\n  const cancelPointerEndListeners = useRef(null);\n  /**\r\n   * Only set listener to passive if there are no external listeners.\r\n   */\n  const eventOptions = {\n    passive: !(onTapStart || onTap || onTapCancel || onPointerDown)\n  };\n  function removePointerEndListener() {\n    cancelPointerEndListeners.current && cancelPointerEndListeners.current();\n    cancelPointerEndListeners.current = null;\n  }\n  function checkPointerEnd() {\n    removePointerEndListener();\n    isPressing.current = false;\n    visualElement.animationState && visualElement.animationState.setActive(AnimationType.Tap, false);\n    return !isDragActive();\n  }\n  function onPointerUp(event, info) {\n    if (!checkPointerEnd()) return;\n    /**\r\n     * We only count this as a tap gesture if the event.target is the same\r\n     * as, or a child of, this component's element\r\n     */\n    !isNodeOrChild(visualElement.current, event.target) ? onTapCancel && onTapCancel(event, info) : onTap && onTap(event, info);\n  }\n  function onPointerCancel(event, info) {\n    if (!checkPointerEnd()) return;\n    onTapCancel && onTapCancel(event, info);\n  }\n  function onPointerDown(event, info) {\n    removePointerEndListener();\n    if (isPressing.current) return;\n    isPressing.current = true;\n    cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n    /**\r\n     * Ensure we trigger animations before firing event callback\r\n     */\n    visualElement.animationState && visualElement.animationState.setActive(AnimationType.Tap, true);\n    onTapStart && onTapStart(event, info);\n  }\n  usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : undefined, eventOptions);\n  useUnmountEffect(removePointerEndListener);\n}\nexport { useTapGesture };","map":{"version":3,"names":["useRef","isNodeOrChild","usePointerEvent","addPointerEvent","useUnmountEffect","pipe","AnimationType","isDragActive","useTapGesture","onTap","onTapStart","onTapCancel","whileTap","visualElement","hasPressListeners","isPressing","cancelPointerEndListeners","eventOptions","passive","onPointerDown","removePointerEndListener","current","checkPointerEnd","animationState","setActive","Tap","onPointerUp","event","info","target","onPointerCancel","window","undefined"],"sources":["C:/Users/ROSHAN JHA/Desktop/project/intelligent-tray-2816/style/node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs"],"sourcesContent":["import { useRef } from 'react';\r\nimport { isNodeOrChild } from './utils/is-node-or-child.mjs';\r\nimport { usePointerEvent, addPointerEvent } from '../events/use-pointer-event.mjs';\r\nimport { useUnmountEffect } from '../utils/use-unmount-effect.mjs';\r\nimport { pipe } from 'popmotion';\r\nimport { AnimationType } from '../render/utils/types.mjs';\r\nimport { isDragActive } from './drag/utils/lock.mjs';\r\n\r\n/**\r\n * @param handlers -\r\n * @internal\r\n */\r\nfunction useTapGesture({ onTap, onTapStart, onTapCancel, whileTap, visualElement, }) {\r\n    const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\r\n    const isPressing = useRef(false);\r\n    const cancelPointerEndListeners = useRef(null);\r\n    /**\r\n     * Only set listener to passive if there are no external listeners.\r\n     */\r\n    const eventOptions = {\r\n        passive: !(onTapStart || onTap || onTapCancel || onPointerDown),\r\n    };\r\n    function removePointerEndListener() {\r\n        cancelPointerEndListeners.current && cancelPointerEndListeners.current();\r\n        cancelPointerEndListeners.current = null;\r\n    }\r\n    function checkPointerEnd() {\r\n        removePointerEndListener();\r\n        isPressing.current = false;\r\n        visualElement.animationState &&\r\n            visualElement.animationState.setActive(AnimationType.Tap, false);\r\n        return !isDragActive();\r\n    }\r\n    function onPointerUp(event, info) {\r\n        if (!checkPointerEnd())\r\n            return;\r\n        /**\r\n         * We only count this as a tap gesture if the event.target is the same\r\n         * as, or a child of, this component's element\r\n         */\r\n        !isNodeOrChild(visualElement.current, event.target)\r\n            ? onTapCancel && onTapCancel(event, info)\r\n            : onTap && onTap(event, info);\r\n    }\r\n    function onPointerCancel(event, info) {\r\n        if (!checkPointerEnd())\r\n            return;\r\n        onTapCancel && onTapCancel(event, info);\r\n    }\r\n    function onPointerDown(event, info) {\r\n        removePointerEndListener();\r\n        if (isPressing.current)\r\n            return;\r\n        isPressing.current = true;\r\n        cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\r\n        /**\r\n         * Ensure we trigger animations before firing event callback\r\n         */\r\n        visualElement.animationState &&\r\n            visualElement.animationState.setActive(AnimationType.Tap, true);\r\n        onTapStart && onTapStart(event, info);\r\n    }\r\n    usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : undefined, eventOptions);\r\n    useUnmountEffect(removePointerEndListener);\r\n}\r\n\r\nexport { useTapGesture };\r\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,OAAO;AAC9B,SAASC,aAAa,QAAQ,8BAA8B;AAC5D,SAASC,eAAe,EAAEC,eAAe,QAAQ,iCAAiC;AAClF,SAASC,gBAAgB,QAAQ,iCAAiC;AAClE,SAASC,IAAI,QAAQ,WAAW;AAChC,SAASC,aAAa,QAAQ,2BAA2B;AACzD,SAASC,YAAY,QAAQ,uBAAuB;;AAEpD;AACA;AACA;AACA;AACA,SAASC,aAAa,OAA+D;EAAA,IAA9D;IAAEC,KAAK;IAAEC,UAAU;IAAEC,WAAW;IAAEC,QAAQ;IAAEC;EAAe,CAAC;EAC/E,MAAMC,iBAAiB,GAAGL,KAAK,IAAIC,UAAU,IAAIC,WAAW,IAAIC,QAAQ;EACxE,MAAMG,UAAU,GAAGf,MAAM,CAAC,KAAK,CAAC;EAChC,MAAMgB,yBAAyB,GAAGhB,MAAM,CAAC,IAAI,CAAC;EAC9C;AACJ;AACA;EACI,MAAMiB,YAAY,GAAG;IACjBC,OAAO,EAAE,EAAER,UAAU,IAAID,KAAK,IAAIE,WAAW,IAAIQ,aAAa;EAClE,CAAC;EACD,SAASC,wBAAwB,GAAG;IAChCJ,yBAAyB,CAACK,OAAO,IAAIL,yBAAyB,CAACK,OAAO,EAAE;IACxEL,yBAAyB,CAACK,OAAO,GAAG,IAAI;EAC5C;EACA,SAASC,eAAe,GAAG;IACvBF,wBAAwB,EAAE;IAC1BL,UAAU,CAACM,OAAO,GAAG,KAAK;IAC1BR,aAAa,CAACU,cAAc,IACxBV,aAAa,CAACU,cAAc,CAACC,SAAS,CAAClB,aAAa,CAACmB,GAAG,EAAE,KAAK,CAAC;IACpE,OAAO,CAAClB,YAAY,EAAE;EAC1B;EACA,SAASmB,WAAW,CAACC,KAAK,EAAEC,IAAI,EAAE;IAC9B,IAAI,CAACN,eAAe,EAAE,EAClB;IACJ;AACR;AACA;AACA;IACQ,CAACrB,aAAa,CAACY,aAAa,CAACQ,OAAO,EAAEM,KAAK,CAACE,MAAM,CAAC,GAC7ClB,WAAW,IAAIA,WAAW,CAACgB,KAAK,EAAEC,IAAI,CAAC,GACvCnB,KAAK,IAAIA,KAAK,CAACkB,KAAK,EAAEC,IAAI,CAAC;EACrC;EACA,SAASE,eAAe,CAACH,KAAK,EAAEC,IAAI,EAAE;IAClC,IAAI,CAACN,eAAe,EAAE,EAClB;IACJX,WAAW,IAAIA,WAAW,CAACgB,KAAK,EAAEC,IAAI,CAAC;EAC3C;EACA,SAAST,aAAa,CAACQ,KAAK,EAAEC,IAAI,EAAE;IAChCR,wBAAwB,EAAE;IAC1B,IAAIL,UAAU,CAACM,OAAO,EAClB;IACJN,UAAU,CAACM,OAAO,GAAG,IAAI;IACzBL,yBAAyB,CAACK,OAAO,GAAGhB,IAAI,CAACF,eAAe,CAAC4B,MAAM,EAAE,WAAW,EAAEL,WAAW,EAAET,YAAY,CAAC,EAAEd,eAAe,CAAC4B,MAAM,EAAE,eAAe,EAAED,eAAe,EAAEb,YAAY,CAAC,CAAC;IAClL;AACR;AACA;IACQJ,aAAa,CAACU,cAAc,IACxBV,aAAa,CAACU,cAAc,CAACC,SAAS,CAAClB,aAAa,CAACmB,GAAG,EAAE,IAAI,CAAC;IACnEf,UAAU,IAAIA,UAAU,CAACiB,KAAK,EAAEC,IAAI,CAAC;EACzC;EACA1B,eAAe,CAACW,aAAa,EAAE,aAAa,EAAEC,iBAAiB,GAAGK,aAAa,GAAGa,SAAS,EAAEf,YAAY,CAAC;EAC1Gb,gBAAgB,CAACgB,wBAAwB,CAAC;AAC9C;AAEA,SAASZ,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}